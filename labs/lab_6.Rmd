---
title: "Lab 4: Probability Distributions"
output: 
  html_document: 
    theme: cosmo
    toc: yes
    toc_depth: 3
    toc_float: TRUE
---

```{r setup, include = FALSE}
# set chunk options
knitr::opts_chunk$set(message = FALSE,
                      warning = FALSE)

# suppress scientific notation
options(scipen = 999)

#load required packages
library(tidyverse) # includes ggplot2
library(here) # used to streamline the creation of this document
library(rio) # for importing data
library(yarrr) # import pirates data

# convert pirates data to a tibble
pirates <- as_tibble(pirates)
```

# Purpose

The purpose of today's lab is to introduce you to visualizing data. Although R has built in plotting functions, we will be using the `ggplot2` package in todays lab. It is far more powerful than the base R plotting functions and is the basis for other packages that allow you to create interactive plots, animated plots, and 3D plots. Being part of the `tidyverse`, `ggplot2` was also designed to work well with other `tidyverse` packages (e.g., `dplyr`, `tidyr`). The content of today's labs will be split into four sections. The first section, [The Grammar of Graphics](#grammar) will provide a brief overview of how `ggplot2` plots work. The second section, [Histograms](#hist), will provide an overview of how to create a histogram and customize it. The third section, [Categorical-Continuous Graphs](#cat), will guide you through the process of creating a barchart in R. Finally, in the [Continuous-Continuous Graphs](#cont) section, we will discuss how to create plots where you have have a continuous variable both axes. As always, the lab will end with [minihacks](#minihacks) to test your knowledge.

To quickly navigate to the desired section, click one of the following links:

1. [The Grammar of Graphics](#grammar)
1. [Histograms](#hist)
1. [Categorical-Continuous Graphs](#cat)
1. [Continuous-Continous Graphs](#cont)
1. [Minihacks](#minihacks)

Today we will be using the `pirates` data set released as part of [TidyTuesday challenge](https://twitter.com/hashtag/tidytuesday?lang=en) on October 22nd, 2019. Every Tuesday, [Thomas Mock](https://thomasmock.netlify.com) releases a data set and challenges data scientists and data enthusiasts to create plots from the data using functions in the `tidyverse`. The plots are then posted to Twitter with the hashtag `#TidyTuesday`. Taking part in [TidyTuesday](https://twitter.com/hashtag/tidytuesday?lang=en) is a fantastic way to improve your plotting skills. 

Below are included some resources that you may find useful going forward:

* Claus O. Wilke's [Fundamentals of Data Visualization](https://serialmentor.com/dataviz/) 
* [The ggplot2 cheatsheet](https://rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf) 
* [Colors in R](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)

***

# The Grammar of Graphics {#grammar}

![](`r here("labs", "resources", "lab6", "grammar_of_graphics.png")`)

The `ggplot2` package is built around Leland Wilkinson's idea of the *Grammar of Graphics*. In its simplest form, the *Grammar of Graphics* suggests that every graph can be created from (1) a data set (e.g., `mtcars`, `world happiness`), (2) a coordinate system (e.g., a cartesian coordinate system), and (3) a set of geometric elements that represent the data (e.g., points, lines, polygons).

***

# Histograms {#hist}

Below is the **data set** `pirates`.

```{r}
# the data set
pirates
```

We can then pipe (`%>%`) that **data set** to `ggplot()` to create the **canvas** of our plot.

```{r}
# the data set
pirates %>%
  # the canvas
  ggplot(aes(x = age))
```

The `aes()` function above tells `ggplot()` that we are providing it aesthetic information for the **canvas**. In this case, we are saying the **canvas** should have `age` on the x-axis. Other aesthetic mappings include `y`, `colour`, `size`, and `shape`, but we will discuss those later.

As we can see, a **canvas** is not that exciting without anything on it. We can add **geometric elements** to a plot by using the functions that begin with `geom_`. Let's add a histogram by adding `geom_histogram()`. Unlike other functions in the `tidyverse`, we use the plus symbol(`+`) instead of the pipe symbol (`%>%`) to add elements to a plot. 

```{r, echo = FALSE}
# the data set
pirates %>%
  # the canvas
  ggplot(aes(x = age)) +
    # the geometric elements
    geom_histogram()
```

Looks like a histogram, but it is a bit hard to distinguish between the different bins. We can use the `fill` and `colour` (or `color`) arguments to specify the colour of the inside and outline of **geometric elements**, respectively. We can also use `alpha` to set the opacity (i.e., the transparency) of the geometric element.

```{r}
# the data set
pirates %>%
  # the canvas
  ggplot(aes(x = age)) +
    # the geometric elements
    geom_histogram(fill   = "turquoise",
                   colour = "black",
                   alpha  = .6)
```

The **geometric element** `geom_histogram()` has an additional argument `binwidth` that allows you to specify how many bings that variable should be categorized into. Let's change the `binwidth` to `35`.

```{r}
# the data set
pirates %>%
  # the canvas
  ggplot(aes(x = age)) +
    # the geometric elements
    geom_histogram(fill   = "turquoise",
                   colour = "black",
                   alpha  = .6,
                   bins   = 35)
```

Looks like our  data is more normal than we previously thought.

We can change the theme of the **canvas** by using the suite of functions that start with `theme_`. I like `theme_bw()`, but other choices include `theme_gray()`, `theme_minimal()`, and `theme_classic()`.

```{r}
# the data set
pirates %>%
  # the canvas
  ggplot(aes(x = age)) +
    # the geometric elements
    geom_histogram(fill   = "turquoise",
                   colour = "black",
                   alpha  = .6,
                   bins   = 35) +
    # set theme
    theme_bw()
```

No plot is complete without proper labels. Fortunately, `ggplot2` has the `labs()` function built in for just this purpose.

```{r}
# the data set
pirates %>%
  # the canvas
  ggplot(aes(x = age)) +
    # the geometric elements
    geom_histogram(fill   = "turquoise",
                   colour = "black",
                   alpha  = .6,
                   bins   = 35) +
    # set theme
    theme_bw() +
    # add labels 
    labs(title    = "Frequency Distribution of Pirate Ages",
         subtitle = "A ggplot plot",
         x        = "Age",
         y        = "Frequency",
         caption  = "Data from that `yarrr` package.")
```

Finally, let's see if the age distribution differs by the pirate's `sex`. To do so, we can use `facet_wrap(~sex)`.

```{r}
# the data set
pirates %>%
  # the canvas
  ggplot(aes(x = age)) +
    # the geometric elements
    geom_histogram(fill   = "turquoise",
                   colour = "black",
                   alpha  = .6,
                   bins   = 35) +
    # set theme
    theme_bw() +
    # add labels 
    labs(title    = "Frequency Distribution of Pirate Ages",
         subtitle = "A ggplot plot",
         x        = "Age",
         y        = "Frequency",
         caption  = "Data from that `yarrr` package.") +
    # split the plot by sex
    facet_wrap(~sex)
    
```

***

# Categorical by Continuous {#cat}

Okay, but when we are looking at our data histograms only get us so far. Usually we are interested in th relationship between at least two variables. Below we've created a canvas with `sex` on the x-axis, specified using `x = sex` inside of the `aes()` function of `ggplot()`, and `height` on the y-axis, specified using `y = height` inside of the `aes()` function of `ggplot()`.

```{r}
# the data set
pirates %>%
  # the canvas
  ggplot(aes(x = sex, y = height))
```

Again, our **canvas** looks like what we would expect. Let's add bars using `geom_col()`.

```{r}
# the data set
pirates %>%
  # the canvas
  ggplot(aes(x = sex, y = height)) +
    # the geometric elements
    geom_col()
```

It looks like it is added up all the heights and didn't take the average. Let's use `group_by()` and `summarize()` to calculate the means of the groups before plotting the values.

```{r}
# the data set
pirates %>%
  # get mean height by sex
  group_by(sex) %>%
  summarise(height_avg = mean(height)) %>%
  # the canvas
  ggplot(aes(x = sex, y = height_avg)) +
    # the geometric elements
    geom_col()
```

There we go! Let's rearrange the columns from shortest to tallest using `reorder(sex, height_avg)`. *Note.* If we wanted to arrange from tallest to shortest, we would use `reorder(sex, -height_avg)`.

```{r}
# the data set
pirates %>%
  # get mean height by sex
  group_by(sex) %>%
  summarise(height_avg = mean(height)) %>%
  # the canvas
  ggplot(aes(x = reorder(sex, height_avg), y = height_avg)) +
    # the geometric elements
    geom_col()
```

Now let's update the colours (using `fill` and `colour`), the opacity (using `alpha`), the width of the bars (using `width`), the theme (using `theme_bw()`), and the labels (using `lab()`).

```{r}
# the data set
pirates %>%
  # get mean height by sex
  group_by(sex) %>%
  summarise(height_avg = mean(height)) %>%
  # the canvas
  ggplot(aes(x = reorder(sex, height_avg), y = height_avg)) +
    # the geometric elements
    geom_col(fill   = "turquoise",
             colour = "white",
             alpha  = .7,
             width  = .5) +
    # set theme
    theme_bw() +
    # add labels 
    labs(title    = "Average height of pirate by pirate sex",
         subtitle = "A ggplot plot",
         x        = "Sex",
         y        = "Height (cm)",
         caption  = "Data from that `yarrr` package.")
```

Now, let's flip our coordinates so that `x` becomes `y` and `y` becomes `x` using `coord_flip()`.

```{r}
# the data set
pirates %>%
  # get mean height by sex
  group_by(sex) %>%
  summarise(height_avg = mean(height)) %>%
  # the canvas
  ggplot(aes(x = reorder(sex, height_avg), y = height_avg)) +
    # the geometric elements
    geom_col(fill   = "turquoise",
             colour = "white",
             alpha  = .7,
             width  = .5) +
    # set theme
    theme_bw() +
    # add labels 
    labs(title    = "Average height of pirate by pirate sex",
         subtitle = "A ggplot plot",
         x        = "Sex",
         y        = "Height (cm)",
         caption  = "Data from that `yarrr` package.") +
    # flip coordinates
    coord_flip()
```

***

# Continuous by Continuous {#cont}

A second, and far more common, type of bivariate (two variable) plot is a scatterplot. A scatterplot has a continuous variable on the x-axis and a continuous variable on the y-axis. Let's create the **canvas** for that plot below by specifying that `height` should be on the x-axis and `weight` should by on the y-axis.

```{r, results = FALSE}
# the data set
pirates %>%
  # the canvas
  ggplot(aes(x = height, y = weight))
```

Let's add some points to our plot using `geom_point`. 

```{r}
# the data set
pirates %>%
  # the canvas
  ggplot(aes(x = height, y = weight)) +
    # the geometric elements
    geom_point() 
```

I haven't mentioned this before, but you can add multiple **geometric elements** to a single plot. Let's also add a regression line using `geom_smooth()`.

```{r}
# the data set
pirates %>%
  # the canvas
    ggplot(aes(x = height, y = weight)) +
      # the geometric elements
      geom_point() +
      geom_smooth()
```

It may be hard to see given how linear the data appears to be, but the line is actually slightly curved. Let's change that by specifying `method = "lm"` in the `geom_smooth` function to use linear modelling to plot the line. Let's also get rid of the confidence interval around the line by specifying `se = FALSE`.

```{r}
# the data set
pirates %>%
  # the canvas
    ggplot(aes(x = height, y = weight)) +
    # the geometric elements
    geom_point() +
      geom_smooth(method = "lm", 
                  se     = FALSE)
```

What if we wanted to distinguish the points by the pirates sex? As mentioned before, we can also specify an aesthetic mapping for colour (and fill). Let's map the point colours to the pirates' sexes by including `aes(colour = sex))` in the `geom_point()` function.

```{r}
# the data set
pirates %>%
  # the canvas
    ggplot(aes(x = height, y = weight)) +
      # the geometric elements
      geom_point(aes(colour = sex)) +
      geom_smooth(method = "lm", 
                  se     = FALSE)
```

Hmm. The points are different colours, but their isn't a separate regresion line for each sex. This is because we only specified `colour = sex` for the aesthetic mappings of geom_point. We could specify `colour = sex` in `geom_point()` and `geom_smooth()` to get different coloured points and regression lines OR we can just specify `colour = sex` inside the `ggplot()` function (where we specified what would be on the x- and y-axis) and `geom_point()` and `geom_smooth()` will inheret the aesthetic mapping. 

```{r}
# the data set
pirates %>%
  # the canvas
    ggplot(aes(x = height, y = weight, colour = sex)) +
      # the geometric elements
      geom_point() +
      geom_smooth(method = "lm", 
                  se     = FALSE)
```

Success! Sort of. I don't really like the colours. Luckily, `ggplot2` has a solution for that: scale functions. Scale functions start with `scale_` and are followed by the aesthetic mapping you wish to scale (e.g., `x`, `y`, `colour`, `fill`, `size`, `alpha`, `shape`). The final part of the function specifies how you would like to scale the axis. For example, `scale_y_log10()` scales the y-axis to be on a logarithmic scale. 

Let's use `scale_colour_manual()` to manually set the colours of the plot


```{r}
# the data set
pirates %>%
  # the canvas
    ggplot(aes(x = height, y = weight, colour = sex)) +
      # the geometric elements
      geom_point() +
      geom_smooth(method = "lm", 
                  se     = FALSE) +
    # manually set colours
    scale_colour_manual(values = c("red", "blue", "green"))
```

That's even worse. Okay, let's use a built in colour palette. To do so, we use the `scale_colour_brewer()` function and specify the colour choice after that. The available palettes can be found [here](http://www.sthda.com/english/wiki/colors-in-r).

```{r}
# the data set
pirates %>%
  # the canvas
    ggplot(aes(x = height, y = weight, colour = sex)) +
      # the geometric elements
      geom_point() +
      geom_smooth(method = "lm", 
                  se     = FALSE) +
    # set colour pallete
    scale_colour_brewer(palette = "Set2")
```

I also really don't like that. Let's use `scale_colour_viridis_d()` to use a colour blind safe pallette.

```{r}
# the data set
pirates %>%
  # the canvas
    ggplot(aes(x = height, y = weight, colour = sex)) +
      # the geometric elements
      geom_point() +
      geom_smooth(method = "lm", 
                  se     = FALSE) +
    # set colour pallete
    scale_colour_viridis_d()
```

Much better! But I still can't distinguish between the different lines. Let's  use `facet_wrap()` to produce a separate plot for each sex.

```{r}
# the data set
pirates %>%
  # the canvas
    ggplot(aes(x = height, y = weight, colour = sex)) +
      # the geometric elements
      geom_point() +
      geom_smooth(method = "lm", 
                  se     = FALSE) +
    # set colour pallete
    scale_colour_viridis_d() +
    # facet wrap by sex
    facet_wrap(~sex)
```

Finally, lets add proper labels (using `labs`), change the theme (using `theme_bw`), and drop the redundant legend (using `theme(legend.position = "none")`).

```{r}
# the data set
pirates %>%
  # the canvas
    ggplot(aes(x = height, y = weight, colour = sex)) +
      # the geometric elements
      geom_point() +
      geom_smooth(method = "lm", 
                  se     = FALSE) +
    # set colour pallete
    scale_colour_viridis_d() +
    # facet wrap by sex
    facet_wrap(~sex) +
    # add labels
    labs(title    = "Associations between height and weight, trifurcated by gender",
         x        = "Height (cm)",
         y        = "Weight (kg)") +
    # set theme
    theme_bw() +
    # remove legend
    theme(legend.position = "none")
```


# Minihacks {#minihacks}

You are welcome to work with a partner or in a small group of 2-3 people. Please feel free to ask the lab leader any questions you might have!

The minihacks will all use the `movies` data set from the `yarrr` package.

## Minihack 1: Histograms

1. Create a histogram of domestic and international revenue combined (`revenue.all`). Is it normally distributed?

```{r}
movies %>%
  ggplot(aes(x = revenue.all)) +
    geom_histogram()
```

1. Change the number of bins to `50`.

```{r}
movies %>%
  ggplot(aes(x = revenue.all)) +
    geom_histogram(bins = 50)
```


1. Change the theme of the **canvas** to your preferred theme.

```{r}
movies %>%
  ggplot(aes(x = revenue.all)) +
    geom_histogram(bins = 50) +
    theme_bw()
```

1. Change the `fill` and the `colour` of the histogram. 

```{r}
movies %>%
  ggplot(aes(x = revenue.all)) +
    geom_histogram(bins = 50, fill = "darkorchid4", colour = "white") +
    theme_bw()
```

1. Add an informative title and a label for the x and the y axis.

```{r}
movies %>%
  ggplot(aes(x = revenue.all)) +
    geom_histogram(bins = 50, fill = "darkorchid4", colour = "white") +
    theme_bw() +
    labs(x = "International Revenue",
         y = "Frequency")
```

## Minihack 2: Categorical by Continuous Plots

1. Create a barplot of the all revenue by the movie genre. (*Hint.* You will want to calculate the mean revenue for each genre before your plot it.).

```{r}
movies %>%
  group_by(genre) %>%
  summarize(revenue_avg = mean(revenue.all)) %>%
  ggplot(aes(x = genre, y = revenue_avg)) +
    geom_col()
```

1. Reorder the bars from the lowest revenue to the greatest. 

```{r}
movies %>%
  group_by(genre) %>%
  summarize(revenue_avg = mean(revenue.all)) %>%
  ggplot(aes(x = reorder(genre, revenue_avg), y = revenue_avg)) +
    geom_col()
```

1. Flip the coordinates by adding the function `coord_flip()`

```{r}
movies %>%
  group_by(genre) %>%
  summarize(revenue_avg = mean(revenue.all)) %>%
  ggplot(aes(x = reorder(genre, revenue_avg), y = revenue_avg)) +
    geom_col() +
    coord_flip()
```

1. Facet wrap the plot by movie rating. 

```{r}
movies %>%
  group_by(genre) %>%
  summarize(revenue_avg = mean(revenue.all)) %>%
  ggplot(aes(x = reorder(genre, revenue_avg), y = revenue_avg)) +
    geom_col() +
    coord_flip()
```

## Minihack 3: Continuous by Continuous plot

```{r}
movies %>%
  na.omit() %>%
  filter(rating != "Not Rated") %>%
  ggplot(aes(x = year, 
             y = revenue.all,
             colour = rating)) +
    geom_point(aes(size = budget),
               alpha = .5,
               shape = 18) +
    geom_smooth(method = "lm", se = FALSE) +
    scale_y_log10() +
    scale_colour_viridis_d() +
    facet_wrap(~genre) +
    theme_minimal() +
    labs(x = "Revenue",
         y = "Year")
```
